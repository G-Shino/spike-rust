## 所有権について
- スタック：高速。積み重ねる。pushとpop。LIFO。ポインタ自体はこっちに格納される。
- ヒープ：allocateされる。ごちゃごちゃしている。サイズが可変。ポインタでアクセス。低速。
- 所有権が、どれがどのヒープ上のデータを参照しているかの管理・重複データの最小化・ヒープ上の未使用データの掃除　を実現する

- 文字列リテラルは不変
- String型は可変かつ伸長可能なテキストをサポートする allocateとfreeは一対一にしたい
- String型はptr, len , capの三つを持っている ptr先に文字列が存在する
- 単純な値はコピーされる(スタックに同一のものが積まれる)
- 上記のものはCopyトレイトをもつ　単純なスカラー値の集合はCopyでそれ以外はCopyじゃないというイメージ 
- ヒープを参照するものは同一のptrを持っているものが二つあると、二重メモリ開放のリスクがある -> moveする。
- cloneを用いればヒープごとコピーできるが、コストは高い

- 関数に値を渡すときもムーブは生じる　Copyとかも同じ条件
- returnで新たに値を返し、ムーブすることはできるが、たくさん引数があると大変 -> 参照と借用.
- &hogeで参照 ptrが入る
- 関数の引数に参照をとることを借用という
- &mut hogeで可変な参照　ただし、同一スコープの同一データに対して一つの可変参照しかもてない

- ダングリングポインタ ライフタイムが絡む returnがローカル変数の参照とかだ生じる
- スライス型　コレクションの一部の参照 ptr, lenをもつ
- 文字列リテラルは&strであり、スライスなのである
- 引数も&strの方がメモリ効率が良い


