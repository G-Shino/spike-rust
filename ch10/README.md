## ジェネリック型、トレイト、ライフタイム
- ジェネリックな関数にすることで、関数を抽出し、重複を取り除くことができる
- Tを慣習的に使用する
- ジェネリックな型が特定のトレイトを持つか指定するためにはトレイト境界が必要
- ジェネリックな型を使用したコードが遅くならないようにするために、単相化を行う
- ジェネリックを見て、自動で型ごとのenumとかを生成してくれる
- トレイトは他の言語でいうインターフェイスに近い
- 外部のトレイトは型に実装できない
- トレイトにはデフォルトの挙動を設定できる
- ライフタイムの主な目的は、ダングリング参照を回避すること
- あくまで引数のライフタイムの狭い有効範囲のものが使用される　関数内で生成したものの参照は返せない所有ありのものを返す必要がある
- 一部のよくかくライフタイム指定は省略できる
```
最初の規則は、参照である各引数は、独自のライフタイム引数を得るというものです。換言すれば、 1引数の関数は、1つのライフタイム引数を得るということです: fn foo<'a>(x: &'a i32); 2つ引数のある関数は、2つの個別のライフタイム引数を得ます: fn foo<'a, 'b>(x: &'a i32, y: &'b i32); 以下同様。

2番目の規則は、1つだけ入力ライフタイム引数があるなら、そのライフタイムが全ての出力ライフタイム引数に代入されるというものです: fn foo<'a>(x: &'a i32) -> &'a i32。

3番目の規則は、複数の入力ライフタイム引数があるけれども、メソッドなのでそのうちの一つが&selfや&mut selfだったら、 selfのライフタイムが全出力ライフタイム引数に代入されるというものです。 この3番目の規則により、必要なシンボルの数が減るので、メソッドが遥かに読み書きしやすくなります。
```
- 'staticでプログラム全体の期間で有効になる



- ジェネリクスは型に対し柔軟な関数を作るためのもの
- トレイトは型に対し、欲しい振る舞いを指定するもの
- ライフタイムは、参照の有効性の保証     というイメージで良さそう
